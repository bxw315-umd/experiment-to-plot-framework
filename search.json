[
  {
    "objectID": "plot_experiment.html",
    "href": "plot_experiment.html",
    "title": "plot_experiment",
    "section": "",
    "text": "We can motivate this library by generating plots for a simple experiment, various levels of IAA concentration. This is a CHI dataset.\n\niaa_mnge_root = \"../test_data/iaa_mnge\"\nos.listdir(iaa_mnge_root)\n\n['IAA_7.8125uM_MNGE_GCE_2_250206.txt',\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt',\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt',\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt']\n\n\n\nfpath = os.path.join(iaa_mnge_root)\n\nwith open(os.path.join(fpath, \"IAA_7.8125uM_MNGE_GCE_2_250206.txt\")) as f:\n    contents = f.read()\n\noutput_dict = parse_chi_file(contents)\noutput_dict[\"numeric_data\"] = {k: v[:5] for k, v in output_dict[\"numeric_data\"].items()} # truncate the numeric data just for better display\n\noutput_dict\n\n{'memo': {'timestamp': '2025-02-06T17:35:06',\n  'technique': 'Differential Pulse Voltammetry',\n  'file': 'iaa_7.8125um_mnge_gce_2_250206.bin',\n  'instrument_model': 'CHI1040C'},\n 'parameters': {'Init E (V)': 0.2,\n  'Final E (V)': 1.0,\n  'Incr E (V)': 0.002,\n  'Amplitude (V)': 0.025,\n  'Pulse Width (sec)': 0.05,\n  'Sample Width (sec)': 0.0167,\n  'Pulse Period (sec)': 0.5,\n  'Quiet Time (sec)': 2.0,\n  'Sensitivity (A/V)': 1e-06},\n 'numeric_data': {'Potential/V': array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n  'Current/A': array([-6.596e-07, -6.557e-07, -6.549e-07, -6.547e-07, -6.545e-07])}}\n\n\nThe objective is to create an interface where the user defines 1. the files that need to be parsed within a dataset 2. how we map each reading to an experimental condition\nThe system automatically figures out which parser to use, based on the file extension (CHI is .txt and Palmsens is .csv). Then it 1. reads in the file data according to the specified files 2. maps each measurement to experimental condition according to the user map 3. calculates all plots required to cover one variable experimental plotting\nArchitecturally, we can have the user define a map that takes in a file path and maps it to a tuple, assuming there’s only one measurement within the file. This provides all files as well as the mapping to experimental conditions at the same time This means files with multiple measurements are not yet supported.\n\nfpath_to_experimental_vars = {\n    'IAA_7.8125uM_MNGE_GCE_2_250206.txt': 7.8125,\n    'IAA_62.5uM_MNGE_GCE_2_250206.txt': 62.5,\n    'IAA_31.25uM_MNGE_GCE_2_250206.txt': 31.25,\n    'IAA_15.625uM_MNGE_GCE_2_250206.txt': 15.625,\n}\n\nNow we just build the class that takes this in\n\nclass ExperimentPlotter:\n    def __init__(\n        self,\n        fpath_to_experimental_vars: dict[str, any or tuple] # mapping from fpath to experimental variables (if there's only one), or a tuple of experimental variables\n    ):\n        # save experimental vars\n        self.fpath_to_experimental_vars = _load_fpath_to_experimental_vars(fpath_to_experimental_vars)\n\n# normal function\nassert ExperimentPlotter(fpath_to_experimental_vars).fpath_to_experimental_vars == {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7.8125,),\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (62.5,),\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\n\n# error when expt vars isn't a consistent shape\ntest_fail(lambda: ExperimentPlotter({\"a.csv\": 1, \"b.csv\": 2, \"c.csv\": (1, 2)}))\n\nThat covers user input. Now, we need to read in the file data. If it’s a .txt file, we read and parse CHI, asserting that there’s only one channel’s-worth of information. IF it’s a .csv file, we parse Palmsens, asserting that there’s only one measurement in the file.\n\nsource\n\nprocess_file\n\n process_file (fpath)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfpath\n\nPotentiostat output file (.csv for Palmsens or .txt for CHI)\n\n\nReturns\ndict\ndictionary with \"potential (potential in V) and \"current\" (current in A)\n\n\n\n\nsource\n\n\npalmsens_postprocessor\n\n palmsens_postprocessor (parser_output)\n\n\nsource\n\n\npalmsens_read\n\n palmsens_read (fpath)\n\n\nsource\n\n\nchi_postprocessor\n\n chi_postprocessor (parser_output)\n\n\nsource\n\n\nchi_read\n\n chi_read (fpath)\n\n\n# testing on CHI\nfpath = 'IAA_62.5uM_MNGE_GCE_2_250206.txt'\nchi_output = {k: v[:5] for k, v in process_file(os.path.join(iaa_mnge_root, fpath)).items()}\ntest(chi_output, {'potential': np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]), 'current': np.array([-6.733e-07, -6.715e-07, -6.721e-07, -6.728e-07, -6.733e-07])}, all_equal)\n\n# testing on Palmsens\nfpath = \"../test_data/iaa_m9_pH/250211_Blank_M9_pH5_GCE_DPV.csv\"\nps_output = {k: v[:5] for k, v in process_file(fpath).items()}\ntest(ps_output, {'potential': np.array([0.        , 0.01020757, 0.02041514, 0.03062271, 0.04083028]), 'current': np.array([2.1246306e-08, 2.0322310e-08, 1.9476714e-08, 1.9017516e-08,\n       1.8608716e-08])}, all_equal)\n\nSo we’ve got the code that reads in the data. We’ve got the map. Now we need the code that generates the files we need according to experimental parameters\nFor instance, if we had concentrations [0, 5, 10, 15], then it should be a single plot with all of them in order [(0, 5, 10, 15)]. If we had two variables, we might have experimental value tuples of [(0, 5), (5, 5), (10, 5), (0, 6), (5, 6), (10, 6), (0, 7), (5, 7), (10, 7)] where each tuple represents (concentration, pH). In other words, it’d be a grid of concentrations of [0, 5, 10] and pHs of [5, 6, 7]. Then it’d would be\n[\n    [(0, 5), (5, 5), (10, 5)], # change conc, pH=5\n    [(0, 6), (5, 6), (10, 6)], # change conc, pH=6\n    [(0, 7), (5, 7), (10, 7)], # change conc, pH=7\n    [(0, 5), (0, 6), (0, 7)], # conc=0, change pH\n    [(5, 5), (5, 6), (5, 7)], # conc=5, change pH\n    [(10, 5), (10, 6), (10, 7)] # conc=10, change pH\n]\nIn other words, for each unique variable value within a dimension, keep that dimension constant and then change the other one. To keep it simple, we’re only supporting a max of two experimental variables. Three is uncommon and requires a more generalized algorithm.\nSo, we’re making an algorithm that takes in all the tuples generated by mapping. if tuples are only len 1, then just sort them and that’s the job done. If tuples are len 2, then go through the first dimension’s unique values and group everything that way. Then do the analogous operation on the other dimension.\n\nsingle_tuple_list = [(3,), (8,), (7,), (1,), (5,)]\nexperimental_tuples = single_tuple_list\n\n# if it's len 1, then just sort by that single dimension. and there's only one plot\nplot_combos = [sorted(set(single_tuple_list), key=lambda x: x[0])] # the set part is to remove duplicates\nplot_combos\n\n[[(1,), (3,), (5,), (7,), (8,)]]\n\n\n\ndouble_tuple_list = [(0, 5), (5, 5), (10, 5), (10, 7), (5, 7), (0, 7), (0, 6), (10, 6), (5, 6)]\nexperimental_tuples = np.array(double_tuple_list)\n\n# zero-th column is the one we're sorting on. this is just an example to get started. the example covers the first column only\nunique_col, other_col = 0, 1\nunique_var, var_indices = np.unique(experimental_tuples[:, 0], axis=0, return_inverse=True) # unique values for the first column\n\ncurrent_plot_list = experimental_tuples[var_indices == 0].tolist()\ncurrent_plot_list\n\n[[0, 5], [0, 7], [0, 6]]\n\n\n\n# now sort it and make it tuples\nsorted([tuple(x) for x in current_plot_list], key=lambda x: x[other_col]) # this is the output we want\n\n[(0, 5), (0, 6), (0, 7)]\n\n\n\nplot_list = []\n\nfor i in range(len(unique_var)):\n    current_plot_list = experimental_tuples[var_indices == i].tolist()\n    current_plot_list = sorted([tuple(x) for x in current_plot_list], key=lambda x: x[other_col])\n    plot_list.append(current_plot_list)\n\nplot_list\n\n[[(0, 5), (0, 6), (0, 7)],\n [(5, 5), (5, 6), (5, 7)],\n [(10, 5), (10, 6), (10, 7)]]\n\n\nwe’ve built up all plots in terms of their experimental variables for the first column (concentration), now we just switch the values for unique_col and other col to get the plots for the second column\n\nunique_col, other_col = 1, 0\nunique_var, var_indices = np.unique(experimental_tuples[:, unique_col], axis=0, return_inverse=True) # unique values for unique_col\n\nplot_list = []\n\nfor i in range(len(unique_var)):\n    current_plot_list = experimental_tuples[var_indices == i].tolist()\n    current_plot_list = sorted([tuple(x) for x in current_plot_list], key=lambda x: x[other_col])\n    plot_list.append(current_plot_list)\n\nplot_list\n\n[[(0, 5), (5, 5), (10, 5)],\n [(0, 6), (5, 6), (10, 6)],\n [(0, 7), (5, 7), (10, 7)]]\n\n\nand that’s correct for the second column. which means we can just put everything together and it should work.\n\nsource\n\n\ngenerate_plot_vars\n\n generate_plot_vars (var_tuples:list[tuple])\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvar_tuples\nlist\nlist of experimental values tuples. assumed to all have the same length\n\n\n\n\nsource\n\n\ngenerate_plot_vars_len_two_helper\n\n generate_plot_vars_len_two_helper (var_tuples:list[tuple],\n                                    unique_col:int)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvar_tuples\nlist\ninput tuples\n\n\nunique_col\nint\nthe index of the column to keep constant. either 0 or 1\n\n\n\n\n# single variable case\nassert generate_plot_vars([(3,), (8,), (7,), (1,), (5,)]) == [[(1,), (3,), (5,), (7,), (8,)]]\n\n# another similar case, floats\nassert generate_plot_vars([(1.1,), (1.5,), (3.1,), (0.2,), (1.7,)]) == [[(0.2,), (1.1,), (1.5,), (1.7,), (3.1,)]]\n\n# with a duplicate (expected behavior is to deduplicate)\nassert generate_plot_vars([(3,), (3,), (5,)]) == [[(3,), (5,)]]\n\n# double variable case\nassert generate_plot_vars([(0, 5), (5, 5), (10, 5), (10, 7), (5, 7), (0, 7), (0, 6), (10, 6), (5, 6)]) == [[(0, 5), (0, 6), (0, 7)],\n [(5, 5), (5, 6), (5, 7)],\n [(10, 5), (10, 6), (10, 7)],\n [(0, 5), (5, 5), (10, 5)],\n [(0, 6), (5, 6), (10, 6)],\n [(0, 7), (5, 7), (10, 7)]]\n\n# different case: conc=0 has an additional pH=8, pH=7 is missing its conc=5. in other words, removed (5, 7) and added (0, 8)\nassert generate_plot_vars([(0, 5), (5, 5), (10, 5), (10, 7), (0, 7), (0, 6), (10, 6), (5, 6), (0, 8)]) == [[(0, 5), (0, 6), (0, 7), (0, 8)],\n [(5, 5), (5, 6)],\n [(10, 5), (10, 6), (10, 7)],\n [(0, 5), (5, 5), (10, 5)],\n [(0, 6), (5, 6), (10, 6)],\n [(0, 7), (10, 7)]]\n\nfantastic. now that we’ve generated the plots according to vars, we just need to map vars back to files.\n\nfpath_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7.8125,),\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (62.5,),\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\n\n# because one var can have multiple fpaths, reversal is a tad more complicated than reversing keys and values\nunique_vars, vars_inverse = np.unique(list(fpath_to_vars.values()), axis=0, return_inverse=True)\nunique_vars, vars_inverse\n\n(array([[ 7.8125],\n        [15.625 ],\n        [31.25  ],\n        [62.5   ]]),\n array([0, 3, 2, 1]))\n\n\n\nfpaths = np.array(list(fpath_to_vars.keys()))\n{tuple(var): fpaths[vars_inverse == i].tolist() for i, var in enumerate(unique_vars.tolist())}\n\n{(7.8125,): ['IAA_7.8125uM_MNGE_GCE_2_250206.txt'],\n (15.625,): ['IAA_15.625uM_MNGE_GCE_2_250206.txt'],\n (31.25,): ['IAA_31.25uM_MNGE_GCE_2_250206.txt'],\n (62.5,): ['IAA_62.5uM_MNGE_GCE_2_250206.txt']}\n\n\n\nsource\n\n\ninverse_fpath_to_vars\n\n inverse_fpath_to_vars (fpath_to_vars:dict[str,tuple])\n\n\nassert inverse_fpath_to_vars({'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7.8125,),\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (62.5,),\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}) == {(7.8125,): ['IAA_7.8125uM_MNGE_GCE_2_250206.txt'],\n (15.625,): ['IAA_15.625uM_MNGE_GCE_2_250206.txt'],\n (31.25,): ['IAA_31.25uM_MNGE_GCE_2_250206.txt'],\n (62.5,): ['IAA_62.5uM_MNGE_GCE_2_250206.txt']}\n\nassert inverse_fpath_to_vars({\"5uM.txt\": (5,), \"5uM (1).txt\": (5,), \"10uM\": (10,)}) == {(5,): ['5uM.txt', '5uM (1).txt'], (10,): ['10uM']}\n\nAnd finally, we need to work out some specifics on plotting (coloring when there are multiple lines representing the same vars)\n\ndev_fpaths_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7,), # labeled 7\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (7,), # also labeled 7, just to test when multiple fpaths map to a single var\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\ndev_fpaths_to_vars = {os.path.join(iaa_mnge_root, k): v for k, v in dev_fpaths_to_vars.items()}\n\nvars_to_fpaths = inverse_fpath_to_vars(dev_fpaths_to_vars)\nvars_to_fpaths\n\n{(7.0,): ['../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt',\n  '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt'],\n (15.625,): ['../test_data/iaa_mnge/IAA_15.625uM_MNGE_GCE_2_250206.txt'],\n (31.25,): ['../test_data/iaa_mnge/IAA_31.25uM_MNGE_GCE_2_250206.txt']}\n\n\n\n# now we generate the plots we need to make\nlist_of_plot_vars = list(dev_fpaths_to_vars.values())\nto_plot_list = generate_plot_vars(list_of_plot_vars)\nto_plot_list\n\n[[(7,), (15.625,), (31.25,)]]\n\n\nand now we need a new function that takes in a plot specified by vars (that’s an element of to_plot_list) as well as vars_to_fpaths and generates the plot\n\n# let's do a single element for now\nto_plot = to_plot_list[0]\ncurrent_var = to_plot[0]\n\nfpaths_to_plot = vars_to_fpaths[current_var]\nfpaths_to_plot\n\n['../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt',\n '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt']\n\n\n\n# time to transform them into plot specs\n# first, so colors make sense, we actually need to assign colors to all tuples that will be plotted\nto_plot # map these to colors\n\n[(7,), (15.625,), (31.25,)]\n\n\n\ncolors = list(mcd.TABLEAU_COLORS) # these are the colors for the traces\ncolors\n\n['tab:blue',\n 'tab:orange',\n 'tab:green',\n 'tab:red',\n 'tab:purple',\n 'tab:brown',\n 'tab:pink',\n 'tab:gray',\n 'tab:olive',\n 'tab:cyan']\n\n\n\nsource\n\n\nassign_colors\n\n assign_colors (elements)\n\n\n# normal case\nassert assign_colors(to_plot) == {(7,): 'tab:blue', (15.625,): 'tab:orange', (31.25,): 'tab:green'}\n\n# more elements than colors should result in cycling\nassert assign_colors(list(range(20))) == {0: 'tab:blue',\n 1: 'tab:orange',\n 2: 'tab:green',\n 3: 'tab:red',\n 4: 'tab:purple',\n 5: 'tab:brown',\n 6: 'tab:pink',\n 7: 'tab:gray',\n 8: 'tab:olive',\n 9: 'tab:cyan',\n 10: 'tab:blue',\n 11: 'tab:orange',\n 12: 'tab:green',\n 13: 'tab:red',\n 14: 'tab:purple',\n 15: 'tab:brown',\n 16: 'tab:pink',\n 17: 'tab:gray',\n 18: 'tab:olive',\n 19: 'tab:cyan'}\n\nnow getting back on track\n\n# load fpaths to vars\ndev_fpaths_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7,), # labeled 7\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (7,), # also labeled 7, just to test when multiple fpaths map to a single var\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\ndev_fpaths_to_vars = {os.path.join(iaa_mnge_root, k): v for k, v in dev_fpaths_to_vars.items()}\n\nfpaths_to_data = {fpath: process_file(fpath) for fpath in dev_fpaths_to_vars} # read the data\n\nvars_to_fpaths = inverse_fpath_to_vars(dev_fpaths_to_vars) # generate inverse\n\n\nlist_of_plot_vars = list(dev_fpaths_to_vars.values())\nto_plot_list = generate_plot_vars(list_of_plot_vars)\n\nto_plot = to_plot_list[0]\ncolors = assign_colors(to_plot) # {(7,): 'tab:blue', (15.625,): 'tab:orange', (31.25,): 'tab:green'}\n\ncurrent_var = to_plot[0]\nfpaths_to_plot = vars_to_fpaths[current_var] # ['../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt', '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt']\nfpath_to_plot = fpaths_to_plot[0] # just the first one\n\n# for a trace (a single line on the graph), i need the potential and current data\ncurrent_data_dict = fpaths_to_data[fpath_to_plot]\nsingle_trace = [(current_data_dict[\"potential\"], current_data_dict[\"current\"]), {\"color\": colors[current_var], \"label\": f\"{current_var[0]} uM\"}]\n\n[[arr[:5] for arr in single_trace[0]], single_trace[1]] # show a subset of the data\n\n[[array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n  array([-6.596e-07, -6.557e-07, -6.549e-07, -6.547e-07, -6.545e-07])],\n {'color': 'tab:blue', 'label': '7 uM'}]\n\n\n\nmpl_wrapper([single_trace], xlabel=\"Potential (V)\", ylabel=\"Current (A)\")\n\n\n\n\n\n\n\n\nand then, in general,\n\n# load fpaths to vars\ndev_fpaths_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7,), # labeled 7\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (7,), # also labeled 7, just to test when multiple fpaths map to a single var\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\ndev_fpaths_to_vars = {os.path.join(iaa_mnge_root, k): v for k, v in dev_fpaths_to_vars.items()}\n\nfpaths_to_data = {fpath: process_file(fpath) for fpath in dev_fpaths_to_vars} # read the data\n\nvars_to_fpaths = inverse_fpath_to_vars(dev_fpaths_to_vars) # generate inverse\n\n\nlist_of_plot_vars = list(dev_fpaths_to_vars.values())\nto_plot_list = generate_plot_vars(list_of_plot_vars)\n\nall_plot_specs = []\n\nfor to_plot in to_plot_list: # to_plot is something like [(7,), (15.625,), (31.25,)], specifying the vars that need to be plotted\n    current_plot_spec = []\n    colors = assign_colors(to_plot) # colors for an individual plot\n\n    for current_var in to_plot: # current_var is something like (7,), representing the unique var that's being plotted \n        fpaths_to_plot = vars_to_fpaths[current_var] # all fpaths with that var combination, e.g. ['../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt', '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt']\n\n        for fpath_to_plot_i, fpath_to_plot in enumerate(fpaths_to_plot):\n            current_data_dict = fpaths_to_data[fpath_to_plot] # collect the data\n            kwargs = {\"color\": colors[current_var]}\n\n            if fpath_to_plot_i == 0: # only for the first one do we label, to avoid redundancy in the legend\n                kwargs |= {\"label\": f\"{current_var[0]} uM\"} # NOTE that this is custom code! we want the user to provide a labeling scheme\n                \n            single_trace = [(current_data_dict[\"potential\"], current_data_dict[\"current\"]), kwargs]\n            current_plot_spec.append(single_trace)\n    \n    all_plot_specs.append(current_plot_spec)\n\n[[[arr[:5] for arr in trace[0]], trace[1]] for trace in all_plot_specs[0]]\n\n[[[array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n   array([-6.596e-07, -6.557e-07, -6.549e-07, -6.547e-07, -6.545e-07])],\n  {'color': 'tab:blue', 'label': '7 uM'}],\n [[array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n   array([-6.733e-07, -6.715e-07, -6.721e-07, -6.728e-07, -6.733e-07])],\n  {'color': 'tab:blue'}],\n [[array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n   array([-6.862e-07, -6.799e-07, -6.774e-07, -6.759e-07, -6.741e-07])],\n  {'color': 'tab:orange', 'label': '15.625 uM'}],\n [[array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n   array([-7.070e-07, -7.018e-07, -6.999e-07, -6.986e-07, -6.975e-07])],\n  {'color': 'tab:green', 'label': '31.25 uM'}]]\n\n\n\nmpl_wrapper(all_plot_specs[0])\n\n\n\n\n\n\n\n\nPutting everying back into ExperimentPlotter,\n\nsource\n\n\nExperimentPlotter\n\n ExperimentPlotter (fpath_to_experimental_vars:dict[str,any],\n                    label_fn:Callable[[tuple],str]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfpath_to_experimental_vars\ndict\n\nmapping from fpath to experimental variables (if there’s only one), or a tuple of experimental variables\n\n\nlabel_fn\nCallable\nNone\nfunction maps an experimental var tuple to the label that will be displayed in a plot\n\n\n\n\n# tests, copied from the first time\n\n# normal operation\nfpath_to_experimental_vars = {\n    'IAA_7.8125uM_MNGE_GCE_2_250206.txt': 7.8125,\n    'IAA_62.5uM_MNGE_GCE_2_250206.txt': 62.5,\n    'IAA_31.25uM_MNGE_GCE_2_250206.txt': 31.25,\n    'IAA_15.625uM_MNGE_GCE_2_250206.txt': 15.625,\n}\nfpath_to_experimental_vars = {os.path.join(iaa_mnge_root, k): v for k, v in fpath_to_experimental_vars.items()}\n\nassert ExperimentPlotter(fpath_to_experimental_vars).fpath_to_experimental_vars == {'../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7.8125,),\n '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt': (62.5,),\n '../test_data/iaa_mnge/IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n '../test_data/iaa_mnge/IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\n\n# error when expt vars isn't a consistent shape\ntest_fail(lambda: ExperimentPlotter(fpath_to_experimental_vars | {\"IAA_62.5uM_MNGE_GCE_2_250206.txt\": (62.5, 2)}).fpath_to_experimental_vars)\n\n# error with nonexistent files\ntest_fail(lambda: ExperimentPlotter({\"a.csv\": 1, \"b.csv\": 2, \"c.csv\": (1, 2)}))\n\n\nfpaths_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7,), # labeled 7\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (7,), # also labeled 7, just to test when multiple fpaths map to a single var\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\nfpaths_to_vars = {os.path.join(iaa_mnge_root, k): v for k, v in fpaths_to_vars.items()}\n\nplot_specs = ExperimentPlotter(fpaths_to_vars, lambda x: f\"{x[0]} uM\").plot_specs\ntest([[[[arr[:5] for arr in trace[0]], trace[1]] for trace in plot_spec] for plot_spec in plot_specs], [[[[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.596e-07, -6.557e-07, -6.549e-07, -6.547e-07, -6.545e-07])],\n   {'color': 'tab:blue', 'label': '7 uM'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.733e-07, -6.715e-07, -6.721e-07, -6.728e-07, -6.733e-07])],\n   {'color': 'tab:blue'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.862e-07, -6.799e-07, -6.774e-07, -6.759e-07, -6.741e-07])],\n   {'color': 'tab:orange', 'label': '15.625 uM'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-7.070e-07, -7.018e-07, -6.999e-07, -6.986e-07, -6.975e-07])],\n   {'color': 'tab:green', 'label': '31.25 uM'}]]], all_equal)\nmpl_wrapper(plot_specs[0])\n\n\nfpaths_to_vars = {'IAA_7.8125uM_MNGE_GCE_2_250206.txt': (7.8125,), # correctly labeled\n 'IAA_62.5uM_MNGE_GCE_2_250206.txt': (62.5,), # correctly labeled\n 'IAA_31.25uM_MNGE_GCE_2_250206.txt': (31.25,),\n 'IAA_15.625uM_MNGE_GCE_2_250206.txt': (15.625,)}\nfpaths_to_vars = {os.path.join(iaa_mnge_root, k): v for k, v in fpaths_to_vars.items()}\n\nplot_specs = ExperimentPlotter(fpaths_to_vars, lambda x: f\"{x[0]} uM IAA\").plot_specs\ntest([[[[arr[:5] for arr in trace[0]], trace[1]] for trace in plot_spec] for plot_spec in plot_specs], [[[[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.596e-07, -6.557e-07, -6.549e-07, -6.547e-07, -6.545e-07])],\n   {'color': 'tab:blue', 'label': '7.8125 uM IAA'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.862e-07, -6.799e-07, -6.774e-07, -6.759e-07, -6.741e-07])],\n   {'color': 'tab:orange', 'label': '15.625 uM IAA'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-7.070e-07, -7.018e-07, -6.999e-07, -6.986e-07, -6.975e-07])],\n   {'color': 'tab:green', 'label': '31.25 uM IAA'}],\n  [[np.array([0.202, 0.204, 0.206, 0.208, 0.21 ]),\n    np.array([-6.733e-07, -6.715e-07, -6.721e-07, -6.728e-07, -6.733e-07])],\n   {'color': 'tab:red', 'label': '62.5 uM IAA'}]]], all_equal)\nmpl_wrapper(plot_specs[0])\n\nnow to test on palmsens\n\niaa_m9_pH_root = \"../test_data/iaa_m9_pH\"\nfpaths = [os.path.join(iaa_m9_pH_root, basepath) for basepath in os.listdir(iaa_m9_pH_root)]\nfpaths\n\nafter getting gpt to assign tuple values,\n\nfpaths_to_vars = {'../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH7_GCE_DPV.csv': (31.25, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH5_GCE_DPV.csv': (0, 5), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH6_GCE_DPV.csv': (62.5, 6), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH5_GCE_DPV.csv': (62.5, 5), '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH5_GCE_DPV.csv': (31.25, 5), '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH6_GCE_DPV.csv': (31.25, 6), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH7_GCE_DPV.csv': (62.5, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH7_GCE_DPV.csv': (0, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH6_GCE_DPV.csv': (0, 6)}\nfpaths_to_vars\n\n\nplot_specs = ExperimentPlotter(fpaths_to_vars, lambda tup: f\"IAA {tup[0]} uM, pH {int(tup[1])}\").plot_specs\nassert len(plot_specs) == 6\nlen(plot_specs)\n\nmpl_wrapper(plot_specs[2], xlabel=\"Potential (V)\", ylabel=\"Current (A)\")\n\nAlthough the code is technically finished, there are a few things I don’t like: 1. We still need to pass xlabel and ylabel to mpl_wrapper. It feels like the plot specs should handle this, as it has the information of what we’re plotting 2. By having everything in the initialization, we don’t allow customization of any steps. A minimal problem right now but for more customization on graph creation, we’ll want to allow subclassing for customization. And then, generating the plots can be calculated on-demand by a method rather than at initialization.",
    "crumbs": [
      "plot_experiment"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "plot",
    "section": "",
    "text": "We want to provide a generic plotting function that standardizes plotting of any data. Therefore, we take in a function that provides a list of args and kwargs and plots them through matplotlib. For instance, plotting a sin wave:\n\nsource\n\nmpl_wrapper\n\n mpl_wrapper (plot_list:list[tuple[list,dict]], xlabel:str=None,\n              ylabel:str=None)\n\nMatplotlib wrapper function. Provides a default plot style given data to plot. Returns a PIL image containing the plot.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nplot_list\nlist\n\na two-element tuple containing (args, kwargs) to pass to matplotlib’s plot function.\n\n\nxlabel\nstr\nNone\nX axis label\n\n\nylabel\nstr\nNone\nY axis label\n\n\nReturns\nImage\n\n\n\n\n\n\nx = np.linspace(0, 2*3.14, 100)\ny = np.sin(x)\ny2 = np.sin(x*2*3.14/5)\ny3 = np.sin(x*2*3.14/4)\ny4 = np.sin(x*2*3.14/3)\n\nplot_list = [\n    ([x, y], {\"label\": \"sin(x)\", \"linestyle\": \"dashed\"}),\n    ([x, y2], {\"label\": \"sin(x*2π/5)\"}),\n    ([x, y3], {\"label\": \"sin(x*2π/4)\"}),\n    ([x, y4], {\"label\": \"sin(x*2π/3)\", \"linewidth\": 3}),\n]\n\nmpl_wrapper(plot_list, xlabel=\"x\", ylabel=\"y\")",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "experiment-to-plot-framework",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "experiment-to-plot-framework"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "experiment-to-plot-framework",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/bxw315-umd/experiment-to-plot-framework.git\nor from conda\n$ conda install -c bxw315-umd experiment_to_plot_framework\nor from pypi\n$ pip install experiment_to_plot_framework\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "experiment-to-plot-framework"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "experiment-to-plot-framework",
    "section": "How to use",
    "text": "How to use\nWe provide a method for turning a list of potential/current dictionaries into a plot\nFill me in please! Don’t forget code examples:\n\nfpaths_to_vars = {'../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH7_GCE_DPV.csv': (31.25, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH5_GCE_DPV.csv': (0, 5), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH6_GCE_DPV.csv': (62.5, 6), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH5_GCE_DPV.csv': (62.5, 5), '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH5_GCE_DPV.csv': (31.25, 5), '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH6_GCE_DPV.csv': (31.25, 6), '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH7_GCE_DPV.csv': (62.5, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH7_GCE_DPV.csv': (0, 7), '../test_data/iaa_m9_pH/250211_Blank_M9_pH6_GCE_DPV.csv': (0, 6)}\nfpaths_to_vars\n\n{'../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH7_GCE_DPV.csv': (31.25, 7),\n '../test_data/iaa_m9_pH/250211_Blank_M9_pH5_GCE_DPV.csv': (0, 5),\n '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH6_GCE_DPV.csv': (62.5, 6),\n '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH5_GCE_DPV.csv': (62.5, 5),\n '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH5_GCE_DPV.csv': (31.25, 5),\n '../test_data/iaa_m9_pH/250211_IAA_31.25uM_inM9_pH6_GCE_DPV.csv': (31.25, 6),\n '../test_data/iaa_m9_pH/250211_IAA_62.5uM_inM9_pH7_GCE_DPV.csv': (62.5, 7),\n '../test_data/iaa_m9_pH/250211_Blank_M9_pH7_GCE_DPV.csv': (0, 7),\n '../test_data/iaa_m9_pH/250211_Blank_M9_pH6_GCE_DPV.csv': (0, 6)}\n\n\n\nplot_specs = ExperimentPlotter(fpaths_to_vars, lambda tup: f\"IAA {tup[0]} uM, pH {int(tup[1])}\").plot_specs\nmpl_wrapper(plot_specs[4], xlabel=\"Potential (V)\", ylabel=\"Current (A)\")",
    "crumbs": [
      "experiment-to-plot-framework"
    ]
  }
]