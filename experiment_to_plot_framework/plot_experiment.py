"""Given an experiment, provide all plots for examining one variable at a time."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_plot_experiment.ipynb.

# %% auto 0
__all__ = ['fuse_processing', 'chi_read', 'chi_postprocessor', 'palmsens_read', 'palmsens_postprocessor', 'process_file',
           'generate_plot_vars_len_two_helper', 'generate_plot_vars', 'inverse_fpath_to_vars', 'assign_colors',
           'ExperimentPlotter']

# %% ../nbs/01_plot_experiment.ipynb 3
from potentiostat_data_parser.chi import parse_chi_file
from potentiostat_data_parser.palmsens import parse_palmsens_file
import warnings # to warn when experiment contains both CHI and Palmsens files
import matplotlib._color_data as mcd
import numpy as np

# %% ../nbs/01_plot_experiment.ipynb 11
# helper function to load fpath to experimental variables while validating
def _load_fpath_to_experimental_vars(fpath_to_experimental_vars):
        # if any values are not within a tuple, wrap them in a one element tuple
        fpath_mapping = {}

        proper_expt_vars_len = None
        for fpath, expt_vars in fpath_to_experimental_vars.items():
            if not isinstance(expt_vars, tuple):
                expt_vars = (expt_vars, ) # cast if necessary
                expt_vars_len = 1
            else:
                expt_vars_len = len(expt_vars)
            
            # check that expt vars len is consistent with all others
            if not proper_expt_vars_len:
                proper_expt_vars_len = expt_vars_len # set the proper len if it hasn't been set yet
            else:
                if proper_expt_vars_len != expt_vars_len:
                    raise ValueError(f"The experimental variables for fpath {fpath!r} ({expt_vars!r}) has length ({len(expt_vars)!r}) whereas other data has length ({proper_expt_vars_len!r})")
            
            fpath_mapping[fpath] = expt_vars

        return fpath_mapping

# %% ../nbs/01_plot_experiment.ipynb 14
def chi_read(fpath):
    with open(fpath, "r", encoding="utf-8") as f:
        return f.read()

def chi_postprocessor(parser_output):
    data = parser_output["numeric_data"]
    if "Current/A" not in data:
        raise ValueError(f"Current/A not detected as a data column. Instead, found {list(data.keys())!r}. Note that multichannel data is not supported yet.")

    return { "potential": data["Potential/V"], "current": data["Current/A"] }

def palmsens_read(fpath):
    with open(fpath, "r", encoding="utf-16") as f:
        return f.read()

def palmsens_postprocessor(parser_output):
    if len(parser_output) != 1:
        raise ValueError(f"We currently only support one measurement per file, but this file contains {len(parser_output)!r} measurements.")
    data = parser_output[0]
    return { "potential": data["potential"], "current": data["current"] }

fuse_processing = lambda read, parse, postprocess: (lambda fpath: postprocess(parse(read(fpath))))

def process_file(
    fpath # Potentiostat output file (.csv for Palmsens or .txt for CHI)
) -> dict[str: np.ndarray]: # dictionary with `"potential` (potential in V) and `"current"` (current in A)
    if fpath.endswith(".txt"):
        processor = fuse_processing(chi_read, parse_chi_file, chi_postprocessor)
    elif fpath.endswith(".csv"):
        processor = fuse_processing(palmsens_read, parse_palmsens_file, palmsens_postprocessor)

    return processor(fpath)

# %% ../nbs/01_plot_experiment.ipynb 26
def generate_plot_vars_len_two_helper(
    var_tuples: list[tuple], # input tuples 
    unique_col: int, # the index of the column to keep constant. either 0 or 1
):
    if unique_col not in [0, 1]: raise ValueError(f"Expected unique_col to be either 0 or 1, but received {unique_col!r}")
    other_col = 0 if unique_col == 1 else 1

    if isinstance(var_tuples, list):
        var_tuples = np.array(var_tuples)
    
    unique_var, var_indices = np.unique(var_tuples[:, unique_col], axis=0, return_inverse=True) # unique values for unique_col
    plot_list = []

    # generate the one variable change plot specs in terms of experimental varA
    for i in range(len(unique_var)):
        current_plot_list = var_tuples[var_indices == i].tolist()
        current_plot_list = sorted([tuple(x) for x in current_plot_list], key=lambda x: x[other_col])

        if len(current_plot_list) > 1: # don't bother adding plots that are a single measurement
            plot_list.append(current_plot_list)

    return plot_list

def generate_plot_vars(
    var_tuples: list[tuple] # list of experimental values tuples. assumed to all have the same length
):
    tuple_len = len(var_tuples[0])
    if tuple_len == 0:
        return []
    if tuple_len == 1: # single var case
        return [sorted(set(var_tuples), key=lambda x: x[0])]
    elif tuple_len == 2: # double var case
        first_column_list = generate_plot_vars_len_two_helper(var_tuples, 0)
        second_column_list = generate_plot_vars_len_two_helper(var_tuples, 1)
        return first_column_list + second_column_list
    else:
        raise ValueError(f"Expected tuple length of either 1 or 2, but received tuple length {tuple_len!r}. Tuple length greater than 2 is not supported.")

# %% ../nbs/01_plot_experiment.ipynb 31
def inverse_fpath_to_vars(fpath_to_vars: dict[str, tuple or any]):
    unique_vars, vars_inverse = np.unique(list(fpath_to_vars.values()), axis=0, return_inverse=True) # find unique values of vars, get inverse so we can reverse the relationship
    fpaths = np.array(list(fpath_to_vars.keys())) # cast so we can slice numpy arrays
    return {tuple(var): fpaths[vars_inverse == i].tolist() for i, var in enumerate(unique_vars.tolist())}

# %% ../nbs/01_plot_experiment.ipynb 40
def assign_colors(elements):
    colors = list(mcd.TABLEAU_COLORS)
    return {tup: colors[i % len(colors)] for i, tup in enumerate(elements)}

# %% ../nbs/01_plot_experiment.ipynb 49
from typing import Callable

class ExperimentPlotter:
    def __init__(
        self,
        fpath_to_experimental_vars: dict[str, any or tuple], # mapping from fpath to experimental variables (if there's only one), or a tuple of experimental variables
        label_fn: Callable[[tuple], str] or None=None # function maps an experimental var tuple to the label that will be displayed in a plot
    ):
        self.fpath_to_experimental_vars = _load_fpath_to_experimental_vars(fpath_to_experimental_vars) # save experimental vars
        self.fpaths_to_data = {fpath: process_file(fpath) for fpath in self.fpath_to_experimental_vars} # grab the data
        self.vars_to_fpaths = inverse_fpath_to_vars(self.fpath_to_experimental_vars) # generate inverse of fpath_to_experimental_vars

        if not label_fn:
            label_fn = lambda x: str(x)
        self.label_fn = label_fn
        
        # generate plots in terms of vars
        list_of_plot_vars = list(self.fpath_to_experimental_vars.values())
        to_plot_list = generate_plot_vars(list_of_plot_vars)
        all_plot_specs = []
        
        for to_plot in to_plot_list: # to_plot is something like [(7,), (15.625,), (31.25,)], specifying the vars that need to be plotted
            current_plot_spec = []
            colors = assign_colors(to_plot) # colors for an individual plot
        
            for current_var in to_plot: # current_var is something like (7,), representing the unique var that's being plotted 
                fpaths_to_plot = self.vars_to_fpaths[current_var] # all fpaths with that var combination, e.g. ['../test_data/iaa_mnge/IAA_7.8125uM_MNGE_GCE_2_250206.txt', '../test_data/iaa_mnge/IAA_62.5uM_MNGE_GCE_2_250206.txt']
        
                for fpath_to_plot_i, fpath_to_plot in enumerate(fpaths_to_plot):
                    current_data_dict = self.fpaths_to_data[fpath_to_plot] # collect the data
                    kwargs = {"color": colors[current_var]}
        
                    if fpath_to_plot_i == 0: # only for the first one do we label, to avoid redundancy in the legend
                        kwargs |= {"label": label_fn(current_var)}
                        
                    single_trace = [(current_data_dict["potential"], current_data_dict["current"]), kwargs]
                    current_plot_spec.append(single_trace)
            
            all_plot_specs.append(current_plot_spec)
        self.plot_specs = all_plot_specs
